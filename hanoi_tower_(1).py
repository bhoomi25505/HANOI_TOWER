# -*- coding: utf-8 -*-
"""HANOI_TOWER (1).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SI120JRTrA92gbH8SxWnexVf1dVwCAzP
"""

t1 = ["ds","dm","dl"]
t2 = []
t3 = []

def show_towers():
    print("T1:", t1)
    print("T2:", t2)
    print("T3:", t3)

def move(start, end, start_name, end_name):
    disk = start.pop()
    end.append(disk)
    print(f"Move {disk} from {start_name} to {end_name}")
    show_towers()


show_towers()
move(t1, t3, "T1", "T3")
move(t1, t2, "T1", "T2")
move(t3, t2, "T3", "T2")
move(t1, t3, "T1", "T3")
move(t2, t1, "T2", "T1")
move(t2, t3, "T2", "T3")
move(t1, t3, "T1", "T3")

print("Final tower state:")
show_towers()

""" Move only one disk at a time.

You can only move the top disk of a tower.

You can‚Äôt place a larger disk on a smaller one."""

# Simple Tic Tac Toe for beginners

# Create empty board
board = [" "] * 9

# Function to print the board
def print_board():
    print(board[0] + "|" + board[1] + "|" + board[2])
    print("-+-+-")
    print(board[3] + "|" + board[4] + "|" + board[5])
    print("-+-+-")
    print(board[6] + "|" + board[7] + "|" + board[8])

# Function to check winner
def check_winner(player):
    # winning positions
    wins = [
        [0,1,2], [3,4,5], [6,7,8],  # rows
        [0,3,6], [1,4,7], [2,5,8],  # cols
        [0,4,8], [2,4,6]            # diagonals
    ]
    for combo in wins:
        if board[combo[0]] == board[combo[1]] == board[combo[2]] == player:
            return True
    return False

# Main game loop
player = "X"
for turn in range(9):
    print_board()
    move = int(input(f"Player {player}, enter position (0-8): "))

    if board[move] == " ":
        board[move] = player
        if check_winner(player):
            print_board()
            print(f"üéâ Player {player} wins!")
            break
        # switch player
        player = "O" if player == "X" else "X"
    else:
        print("That spot is taken. Try again.")
else:
    print_board()
    print("ü§ù It's a tie!")

from collections import deque

def show(s):  # print puzzle
    for i in range(0,9,3): print(s[i:i+3])
    print()

def neighbors(s):
    z = s.index(0)
    x,y = divmod(z,3)
    moves=[(-1,0),(1,0),(0,-1),(0,1)]
    for dx,dy in moves:
        nx,ny = x+dx,y+dy
        if 0<=nx<3 and 0<=ny<3:
            nz=nx*3+ny
            new=s[:]
            new[z],new[nz]=new[nz],new[z]
            yield new

def solve(start,goal):
    q=deque([(start,[])])
    seen=set()
    while q:
        s,path=q.popleft()
        if s==goal: return path+[s]
        seen.add(tuple(s))
        for nxt in neighbors(s):
            if tuple(nxt) not in seen:
                q.append((nxt,path+[s]))

start=[1,2,3,4,0,6,7,5,8]
goal=[1,2,3,4,5,6,7,8,0]

for step in solve(start,goal):
    show(step)

def monkey_task(monkey, banana, box):
    print("Monkey goes from", monkey, "to", box)
    print("Monkey moves box from", box, "to", banana)
    print("Monkey climbs on box")
    print("Monkey picks banana")

monkey_task("Door","Middle","Corner")

M, m = 1000, -1000  # MAX, MIN

def minimax(d, n, mx, v, a, b):
    if d == 3:  # leaf
        return v[n]

    if mx:  # Maximizer
        best = m
        for i in range(2):
            val = minimax(d+1, n*2+i, False, v, a, b)
            best = max(best, val)
            a = max(a, best)
            if b <= a:  # prune
                break
        return best
    else:  # Minimizer
        best = M
        for i in range(2):
            val = minimax(d+1, n*2+i, True, v, a, b)
            best = min(best, val)
            b = min(b, best)
            if b <= a:  # prune
                break
        return best

if __name__ == "__main__":
    v = [3, 5, 6, 9, 1, 2, 0, -1]
    print("Optimal value:", minimax(0, 0, True, v, m, M))

V = 4
ans = []

def tsp(g, vis, pos, n, cnt, cost):
    # If all cities are visited and return path exists
    if cnt == n and g[pos][0]:
        ans.append(cost + g[pos][0])
        return

    # Try all next cities
    for i in range(n):
        if not vis[i] and g[pos][i]:
            vis[i] = True
            tsp(g, vis, i, n, cnt + 1, cost + g[pos][i])
            vis[i] = False  # backtrack

if __name__ == "__main__":
    n = 4
    g = [[0, 10, 15, 20],
         [10, 0, 35, 25],
         [15, 35, 0, 30],
         [20, 25, 30, 0]]

    vis = [False] * n
    vis[0] = True  # start from city 0

    tsp(g, vis, 0, n, 1, 0)
    print("Minimum cost:", min(ans))

N = 4

def printSolution(board):
    for i in range(N):
        for j in range(N):
            print(board[i][j], end=" ")
        print()
    print()

def isSafe(board, row, col):
    # Check this row on left side
    for i in range(col):
        if board[row][i] == 1:
            return False

    # Check upper diagonal on left side
    for i, j in zip(range(row, -1, -1), range(col, -1, -1)):
        if board[i][j] == 1:
            return False

    # Check lower diagonal on left side
    for i, j in zip(range(row, N, 1), range(col, -1, -1)):
        if board[i][j] == 1:
            return False

    return True

def solveNQUtil(board, col):
    # base case: If all queens are placed
    if col >= N:
        return True

    for i in range(N):
        if isSafe(board, i, col):
            board[i][col] = 1  # Place queen

            if solveNQUtil(board, col + 1):  # Recur
                return True

            board[i][col] = 0  # Backtrack

    return False

def solveNQ():
    board = [[0] * N for _ in range(N)]

    if not solveNQUtil(board, 0):
        print("Solution does not exist")
        return False

    printSolution(board)
    return True

# Driver
solveNQ()

from itertools import permutations

def tsp(graph):
    n = len(graph)
    cities = range(n)
    min_cost = float("inf")

    for perm in permutations(cities[1:]):  # fix start at 0
        path = (0,) + perm + (0,)
        cost = sum(graph[path[i]][path[i+1]] for i in range(n))
        min_cost = min(min_cost, cost)

    return min_cost

graph = [
    [0, 10, 15, 20],
    [10, 0, 35, 25],
    [15, 35, 0, 30],
    [20, 25, 30, 0]
]

print("Minimum cost:", tsp(graph))

def solve(n):
    def safe(b,r,c):
        return all(b[i]!=c and abs(b[i]-c)!=r-i for i in range(r))
    def backtrack(r=0,b=[]):
        if r==n:
            print("\n".join(" ".join("Q" if i==c else "." for i in range(n)) for c in b),"\n")
            return 1
        return sum(backtrack(r+1,b+[c]) for c in range(n) if safe(b,r,c))
    s = backtrack()
    print("Total Solutions:",s)

n = int(input("Enter board size: "))
solve(n)